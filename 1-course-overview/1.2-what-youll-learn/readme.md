# What You'll Learn

In this course, we'll cover some of TypeScript's most powerful and useful features.

I'll share over a dozen different ways to safely narrow types, and how to choose between them.

We'll explore generics, which will allow us to write code that works with many different types while still maintaining type safety.

We'll use TypeScript's built-in utility types to generate new types, and explore how they're written to help us understand how we can create our own utilities.

We'll create new types from existing types using advanced features like mapped types, string literal types, conditional types, and more.

TypeScript doesn't exist at compile time, so we'll explore how to implement runtime validation schemas to validate and strongly type your runtime data such as URL parameters, environment variables, form inputs,and API responses. And I'll show how to infer your TypeScript types from runtime schemas so you can enjoy both compile-time and runtime safety.

We'll explore using TypeScript in the real world by reviewing example applications that use popular libraries like React, Express, and Node.js.

Finally, I'll close out the course with recommended next steps including TypeScript performance and debugging tips, key third-party libraries, and resources for practicing your newfound skills.
